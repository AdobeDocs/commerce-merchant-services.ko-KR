---
title: '[!DNL Catalog Service]'
description: '`[!DNL Catalog Service] Adobe Commerce용 는 기본 Adobe Commerce GraphQL 쿼리보다 제품 표시 페이지 및 제품 목록 페이지의 컨텐츠를 훨씬 빠르게 검색하는 방법을 제공합니다.'''
exl-id: 266faca4-6a65-4590-99a9-65b1705cac87
source-git-commit: fb229136728a8e7a8afa077120dbad388d1e4089
workflow-type: tm+mt
source-wordcount: '0'
ht-degree: 0%

---

# [!DNL Catalog Service] Adobe Commerce

다음 [!DNL Catalog Service] Adobe Commerce 확장의 경우 다음을 포함하여 제품 관련 상점 경험을 빠르고 완전히 렌더링할 수 있도록 풍부한 보기 모델(읽기 전용) 카탈로그 데이터를 제공합니다.

* 제품 세부 사항 페이지
* 제품 목록 및 카테고리 페이지
* 검색 결과 페이지
* 제품 회전 메뉴
* 제품 비교 페이지
* 장바구니, 주문 및 위시 목록 페이지와 같이 제품 데이터를 렌더링하는 다른 모든 페이지

다음 [!DNL Catalog Service] 사용 [GraphQL](https://graphql.org/) 제품 데이터를 요청 및 수신하기 위해. GraphQL은 프런트 엔드 클라이언트가 Adobe Commerce과 같은 백엔드에 정의된 API(애플리케이션 프로그래밍 인터페이스)와 통신하는 데 사용하는 쿼리 언어입니다. GraphQL은 가볍고 시스템 통합자가 각 응답의 내용과 순서를 지정할 수 있으므로 널리 사용되는 통신 방법입니다.

Adobe Commerce에는 두 개의 GraphQL 시스템이 있습니다. 핵심 GraphQL 시스템은 쇼핑객이 제품, 고객 계정, 장바구니, 체크아웃 등을 비롯하여 다양한 유형의 페이지와 상호 작용할 수 있도록 다양한 쿼리(읽기 작업) 및 돌연(쓰기 작업)을 제공합니다. 그러나 제품 정보를 반환하는 쿼리는 속도에 최적화되지 않습니다. 서비스 GraphQL 시스템은 제품 및 관련 정보에 대해서만 쿼리를 수행할 수 있습니다. 이러한 쿼리는 유사한 핵심 쿼리보다 성능이 더 좋습니다.

## 아키텍처

다음 다이어그램은 두 GraphQL 시스템을 보여줍니다.

![카탈로그 아키텍처 다이어그램](assets/catalog-service-architecture.png)

코어 GraphQL 시스템에서 PWA은 상거래 애플리케이션에 요청을 전송하여 각 요청을 수신하고 처리하며 여러 하위 시스템을 통해 요청을 전송한 다음 스토어에 대한 응답을 반환합니다. 이 라운드 트립은 페이지 로드 시간이 느려져 전환율이 낮아질 수 있습니다.

[!DNL Catalog Service] 별도의 GraphQL 게이트웨이에 쿼리를 보냅니다. 이 서비스는 제품 속성, 변형, 가격 및 카테고리와 같은 제품 세부 사항 및 관련 정보가 포함된 별도의 데이터베이스에 액세스합니다. 서비스는 색인을 통해 데이터베이스를 Adobe Commerce과 계속 동기화합니다.
서비스는 애플리케이션과 직접 통신을 생략하므로 요청 및 응답 주기의 지연 시간을 줄일 수 있습니다.

>[!NOTE]
>
>게이트웨이는 향후 제품 Recommendations과 통합하기 위한 것입니다. 이 릴리스에서는 [!DNL Catalog Service] 및 [!DNL Live Search] 두 제품에 유효한 라이선스 키가 있는 경우 동일한 종단점의 페더레이션 쿼리를 사용합니다.

코어 및 서비스 GraphQL 시스템은 서로 직접 통신하지 않습니다. 다른 URL에서 각 시스템에 액세스하면 호출에 다른 헤더 정보가 필요합니다. 두 GraphQL 시스템은 함께 사용하도록 설계되었습니다. 다음 [!DNL Catalog Service] GraphQL 시스템은 핵심 시스템을 확장하여 제품 상점 경험을 더 빠르게 만듭니다.

원할 경우 구현할 수 있습니다 [Adobe Developer App Builder용 API Mesh](https://developer.adobe.com/graphql-mesh-gateway/) Adobe Developer을 사용하여 두 Adobe Commerce GraphQL 시스템을 개인 및 타사 API 및 기타 소프트웨어 인터페이스와 통합합니다. 각 종단점으로 라우팅된 호출에 헤더에 올바른 인증 정보가 포함되도록 메쉬를 구성할 수 있습니다.

## 아키텍처 세부 사항

다음 섹션에서는 두 GraphQL 시스템 간의 몇 가지 차이점을 설명합니다.

### 스키마 관리

카탈로그 서비스가 서비스로 작동하므로 통합자는 상거래 기본 버전에 대해 걱정할 필요가 없습니다. 쿼리의 구문은 모든 버전에 대해 동일합니다. 또한 모든 판매자에 대해 스키마가 일관됩니다. 이러한 일관성을 유지하면 모범 사례를 쉽게 설정할 수 있고 상점 위젯의 재사용을 크게 늘릴 수 있습니다.

### 제품 유형 간소화

스키마는 제품 유형의 다양성을 다음 두 가지 사용 사례에 축소합니다.

* 단순 제품은 단일 가격 및 수량으로 정의된 제품입니다. 카탈로그 서비스는 간단한 가상, 다운로드 가능한 및 기프트 카드 제품 유형을 `simpleProductViews`.

* 복합 제품은 여러 가지 간단한 제품으로 구성되어 있습니다. 구성 요소 단순 제품은 가격이 다를 수 있습니다. 복잡한 제품을 정의할 수도 있으므로 쇼핑객이 구성품 단순 제품의 수량을 지정할 수 있습니다. 카탈로그 서비스는 구성 가능한 제품, 번들 및 그룹화된 제품 유형을 `complexProductViews`.

복잡한 제품 선택 사항은 유형이 아니라 해당 동작으로 구분됩니다. 각 옵션 값은 단순 제품을 나타냅니다. 이 옵션 값은 가격을 포함한 간단한 제품 속성에 액세스할 수 있습니다. 쇼핑객이 복잡한 제품에 대한 모든 옵션을 선택하면 선택한 옵션의 조합이 특정 단순 제품을 가리킵니다. 간단한 제품은 쇼핑객이 사용 가능한 모든 옵션에 대한 값을 선택할 때까지 모호합니다.

### 가격

단순 제품은 가격이 있는 기본 판매 단위를 나타냅니다. Catalog Service는 할인 전 일반 가격과 할인 후 최종 가격을 계산합니다. 가격책정 계산에는 고정 제품세가 포함될 수 있습니다. 개인화된 프로모션은 제외합니다.

복잡한 제품에는 정가가 없습니다. 대신, 카탈로그 서비스는 연결된 샘플의 가격을 반환합니다. 예를 들어, 머천트는 처음에 구성 가능한 제품의 모든 변형에 동일한 가격을 지정할 수 있습니다. 특정 크기나 색상이 인기가 없는 경우 상인은 그러한 변형의 가격을 낮출 수 있습니다. 따라서, 상기 복합(구성 가능) 제품의 가격은, 상기 표준 및 비인기 변형의 가격을 모두 반영한 가격 범위를 먼저 표시한다. 쇼핑객이 사용 가능한 모든 옵션에 대한 값을 선택한 후, 스토어에 단일 가격이 표시됩니다.

## 구현

설치 프로세스에는 [Commerce Services 커넥터](../landing/saas.md). 이 작업이 완료되면 시스템 통합자가 상점 코드를 업데이트하여 [!DNL Catalog Service] 쿼리 모두 [!DNL Catalog Service] 쿼리는 GraphQL 게이트웨이로 라우팅됩니다. URL은 온보딩 프로세스 중에 제공됩니다.
